/*
 KSolve+ - Puzzle solving program.
 Copyright (C) 2007-2013 Kåre Krig and Michael Gottlieb

 This program is free software; you can redistribute it and/or
 modify it under the terms of the GNU General Public License
 as published by the Free Software Foundation; either version 2
 of the License, or (at your option) any later version.

 This program is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.

 You should have received a copy of the GNU General Public License
 along with this program; if not, write to the Free Software
 Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
*/

// Functions for generating the pruning tables

#ifndef PRUNING_H
#define PRUNING_H

static PruneTable getCompletePruneTables(Position solved, MoveList moves, PieceTypes datasets, Position ignore, string filename, bool usePruneTable)
{
	PruneTable table;
	string filename2 = filename + ".tables";
	std::ifstream fin;
	fin.open(filename2.c_str(), std::ios::in | std::ios::binary);
	
	bool tablesExist = usePruneTable && fin.is_open(); // do tables exist?
	bool oldTables = false; // are the tables older than the def file?
	
	if (tablesExist) {
		fin.close(); // close ifstream so we can open a handle

		// Changed HANDLE, FILETIME, GetFileTime, CreateFile, and CompareFileTime to Linux/C++ Equivalent -Matt S.
		struct stat defWrite, tableWrite;
		std::ofstream defHandle, tableHandle;
		
		defHandle.open(filename.c_str(), std::ios::in | std::ios::binary);
		if (!defHandle.is_open()) {
			std::cerr << "defHandle fail\n";
			exit(-1);
		}
		if (stat(filename.c_str(), &defWrite) == -1) {
			std::cerr << "stat of def fail\n";
			exit(-1);
		}
		defHandle.close();
		
		tableHandle.open(filename2.c_str(), std::ios::in | std::ios::binary);
		if (!tableHandle.is_open()) {
			std::cerr << "tableHandle fail\n";
			exit(-1);
		}
		if (stat(filename2.c_str(), &tableWrite) == -1) {
			std::cerr << "stat of table fail\n";
			exit(-1);
		}
		tableHandle.close();

		if (difftime(defWrite.st_mtime, tableWrite.st_mtime) > 0) { // yes, def file is newer!
			oldTables = true;
		}
		
		// reopen ifstream
		fin.open(filename2.c_str(), std::ios::in | std::ios::binary);
	}
	
	if (tablesExist && !oldTables){
		std::cout << "Pruning tables found on file.\n";
		
		// Tables exist
		int checksum;
		fin.read((char*) (&checksum), sizeof(checksum)); // Not used yet

		for (int iter=0; iter<solved.size(); iter++) {
			int size = solved[iter].size;
			if (datasets[iter].size != size) std::cout << "WTF\n";
			if (factorial(size) <= MAX_COMPLETE_PERMUTATION_TABLE_SIZE && factorial(size) != -1 && uniquePermutation(solved[iter].permutation, size)){ 
				// Complete tables, unique pieces
				// Read permutation table
				int tab_size = factorial(size);
				table[iter].permutation.reserve(tab_size);

				char *tmp_buff = new char[tab_size+1];
				fin.get(tmp_buff, tab_size+1, 'A');
				for (int i = 0; i < tab_size; i++){
					table[iter].permutation.push_back(tmp_buff[i]);
				}
				delete[] tmp_buff;
			
			}
			else if (combinations(solved[iter].permutation, size) <= MAX_COMPLETE_PERMUTATION_TABLE_SIZE && combinations(solved[iter].permutation, size) != -1 && !uniquePermutation(solved[iter].permutation, size)){ 
				// Complete table, non-unique pieces
				char buff;
				int tab_size = combinations(solved[iter].permutation, size);
				for (int i = 0; i < tab_size; i++){
					fin.read((char*) (&buff), sizeof(buff));
					table[iter].permutation.push_back(buff);
				}
			}
			else{
				// Partial table
				int elements, keysize;
				fin.read((char*) (&elements), sizeof(elements));
				fin.read((char*) (&keysize), sizeof(keysize));

				//std::cout << "elements " << elements << "\n";
				//std::cout << "keysize " << keysize << "\n";
				for (int i = 0; i < elements; i++){
					char depth;
					std::vector<long long> key;
					long long tmp;
					fin.read((char*) (&depth), sizeof(depth));
					key.clear();
					for (int j = 0; j < keysize; j++){
						fin.read((char*) (&tmp), sizeof(tmp));
						key.push_back(tmp);
					}
					table[iter].partialpermutation[key] = depth;
				}
				table[iter].partialpermutation_depth = maxDepth(table[iter].partialpermutation);
			}

			double osize = log(datasets[iter].omod) * size;
			if (osize < log(MAX_COMPLETE_ORIENTATION_TABLE_SIZE)){ // Not to big tables. Using log to avoid overflow.
				long long num = 1;
				for (int t = 0; t < size; t++)
					num *= datasets[iter].omod;
					
					table[iter].orientation.reserve(num);
					
					char *tmp_buff = new char[num+1];
					fin.get(tmp_buff, num+1, 'A');
					for (int i = 0; i < num; i++){
						table[iter].orientation.push_back(tmp_buff[i]);
					}
					delete[] tmp_buff;
			}    
			else{ // Partial orientation tables
				int elements, keysize;
				fin.read((char*) (&elements), sizeof(elements));
				fin.read((char*) (&keysize), sizeof(keysize));
				//std::cout << "elements " << elements << "\n";
				//std::cout << "keysize " << keysize << "\n";
				for (int i = 0; i < elements; i++){
					char depth;
					std::vector<long long> key;
					long long tmp;
					fin.read((char*) (&depth), sizeof(depth));
					key.clear();
					for (int j = 0; j < keysize; j++){
						fin.read((char*) (&tmp), sizeof(tmp));
						key.push_back(tmp);
					}
					table[iter].partialorientation[key] = depth;
				}
				table[iter].partialorientation_depth = maxDepth(table[iter].partialorientation);
			}
		}
		fin.close();
		
	}    
	else{
		if (tablesExist) { // tables exist, but they're old
			std::cout << "Pruning tables older than def file, recomputing.\n";
		} else { // no tables on file
			std::cout << "Pruning tables not found on file, computing.\n";
		}
		table = buildCompletePruneTables(solved, moves, datasets, ignore);
		std::ofstream fout;
		fout.open(filename2.c_str(), std::ios::out | std::ios::binary);
		int checksum = 1; // Not used yet
		fout.write((char*) (&checksum), sizeof(checksum));
		for (int iter=0; iter<solved.size(); iter++) {
			int size = solved[iter].size;
			if (datasets[iter].size != size) std::cout << "WTF\n";
			if (factorial(size) <= MAX_COMPLETE_PERMUTATION_TABLE_SIZE && factorial(size) != -1 && uniquePermutation(solved[iter].permutation, size)){

				// Write permutation table
				int tab_size = factorial(size);
				for (int i = 0; i < tab_size; i++){
					fout.write((char*) (&table[iter].permutation[i]), sizeof(table[iter].permutation[i]));
				}
			}
			else if (combinations(solved[iter].permutation, size) <= MAX_COMPLETE_PERMUTATION_TABLE_SIZE && combinations(solved[iter].permutation, size) != -1){
				// Complete permutation table, not unique pieces
				int tab_size = combinations(solved[iter].permutation, size);
				for (int i = 0; i < tab_size; i++)
					fout.write((char*) (&table[iter].permutation[i]), sizeof(table[iter].permutation[i]));
			}
			else{
				// Partial permutation table  
				// Table entries
				int tmp_size = table[iter].partialpermutation.size();
				fout.write((char*) (&tmp_size), sizeof(tmp_size));
				
				__gnu_pbds::gp_hash_table<std::vector<long long>, char, vec_long_long_hash>::iterator tmp_iter;
				tmp_iter = table[iter].partialpermutation.begin();
				// Key size
				tmp_size = tmp_iter->first.size();
				fout.write((char*) (&tmp_size), sizeof(tmp_size));
				
				for (tmp_iter = table[iter].partialpermutation.begin(); tmp_iter != table[iter].partialpermutation.end(); tmp_iter++){
					// Depth
					fout.write((char*) (&tmp_iter->second), sizeof(tmp_iter->second));
					for (unsigned int i = 0; i < tmp_iter->first.size(); i++)
						fout.write((char*) (&(*tmp_iter).first[i]), sizeof(tmp_iter->first[i]));
						// Keys
				}
			}

			double osize = log(datasets[iter].omod) * size;

			if (osize < log(MAX_COMPLETE_ORIENTATION_TABLE_SIZE)){ // Not too big tables. Using log to avoid overflow.
				for (unsigned int i = 0; i < table[iter].orientation.size(); i++){
					fout.write((char*) (&table[iter].orientation[i]), sizeof(table[iter].orientation[i]));
				}
			}
			else{ // Partial orientation table
				// Table entries
				int tmp_size = table[iter].partialorientation.size();
				fout.write((char*) (&tmp_size), sizeof(tmp_size));

				__gnu_pbds::gp_hash_table<std::vector<long long>, char, vec_long_long_hash>::iterator tmp_iter;
				tmp_iter = table[iter].partialorientation.begin();
				// Key size
				tmp_size = tmp_iter->first.size();
				fout.write((char*) (&tmp_size), sizeof(tmp_size));
				
				for (tmp_iter = table[iter].partialorientation.begin() ; tmp_iter != table[iter].partialorientation.end(); tmp_iter++){
					// Depth
					fout.write((char*) (&tmp_iter->second), sizeof(tmp_iter->second));
					for (unsigned int i = 0; i < tmp_iter->first.size(); i++)
					// Keys
						fout.write((char*) (&(*tmp_iter).first[i]), sizeof(tmp_iter->first[i]));
				}
			}
		}
		fout.close();

	}
	return table;
}
				
static PruneTable buildCompletePruneTables(Position solved, MoveList moves, PieceTypes datasets, Position ignore)
{
	PruneTable table;
	std::vector<int> tmp_ignore;
	for (int iter=0; iter<solved.size(); iter++) {
		int size = solved[iter].size;
		tmp_ignore.clear();
		if (iter < ignore.size() && ignore[iter].size > 0)
			for (int i = 0; i < size; i++)
				tmp_ignore.push_back(ignore[iter].permutation[i]);
			
		if (factorial(size) <= MAX_COMPLETE_PERMUTATION_TABLE_SIZE && factorial(size) != -1 && uniquePermutation(solved[iter].permutation, size)){
			// Complete table, unique pieces
			std::vector<int> temp_perm;
			for (int i = 0; i < size; i++)
				temp_perm.push_back(solved[iter].permutation[i]);
			table[iter].permutation = buildCompletePermutationPruningTable(temp_perm, moves, iter, tmp_ignore);
		}
		else if (combinations(solved[iter].permutation, size) <= MAX_COMPLETE_PERMUTATION_TABLE_SIZE && combinations(solved[iter].permutation, size) != -1 && !uniquePermutation(solved[iter].permutation, size)){
			// Complete table, not unique pieces
			std::vector<int> temp_perm;
			for (int i= 0; i < size; i++)
				temp_perm.push_back(solved[iter].permutation[i]);
			table[iter].permutation = buildCompletePermutationPruningTable3(temp_perm, moves, iter, tmp_ignore);
		}
		else{
			// Partial permutation table 
			std::vector<int> temp_perm;
			for (int i = 0; i < size; i++)
				temp_perm.push_back(solved[iter].permutation[i]);
			table[iter].partialpermutation = buildPartialPermutationPruningTable(temp_perm, moves, iter, tmp_ignore);
			table[iter].partialpermutation_depth = maxDepth(table[iter].partialpermutation);
		}

		tmp_ignore.clear();
		if (iter < ignore.size() && ignore[iter].size > 0)
			for (int i = 0; i < size; i++)
				tmp_ignore.push_back(ignore[iter].orientation[i]);
		double osize = log(datasets[iter].omod) * size;
		if (osize < log(MAX_COMPLETE_ORIENTATION_TABLE_SIZE)){ // Not to big tables. Using log to avoid overflow.
			std::vector<int> temp_orient;
			for (int i = 0; i < size; i++)
				temp_orient.push_back(solved[iter].orientation[i]);
			table[iter].orientation = buildCompleteOrientationPruningTable(temp_orient , moves, iter, datasets[iter].omod, tmp_ignore);
		}
		else{
			std::vector<int> temp_orient;
			for (int i = 0; i < size; i++)
				temp_orient.push_back(solved[iter].orientation[i]);
			table[iter].partialorientation = buildPartialOrientationPruningTable(temp_orient, moves, iter, datasets[iter].omod, tmp_ignore);
			table[iter].partialorientation_depth = maxDepth(table[iter].partialorientation);
		}
	}
	return table;
}                    

static std::vector<char> buildCompleteOrientationPruningTable(std::vector<int> solved, MoveList moves, int setname, int omod, std::vector<int> ignore)
{
	std::cout << "Building pruning for " << setnameFromIndex(setname) << " orientation.\n";
	std::vector<char> table;
	int vector_size = solved.size();
	MoveList::iterator iter;
	int tablesize = 1;
	for (unsigned int i = 0; i < solved.size(); i++)
		tablesize *= omod;  // tablesize = omod to the power of solved.size() 
							// checking for numbers getting too large might be smart
		
	table.resize(tablesize);
	for (int i = 0; i < tablesize; i++)
		table[i] = -1;
		
	std::cout << "tablesize " << tablesize << "\n";

	table[oVector2Index(solved, omod)] = 0; // Put solved position in table

	int len = 0;
	int c;
	do
	{
		c = 0;
		for (int p = 0; p < tablesize; p++){
			if (table[p] == len){
				for (iter = moves.begin(); iter != moves.end(); iter++){
					int q = oVector2Index(applySubmoveO(oIndex2Vector(p, vector_size, omod), iter->second.state[setname].orientation, iter->second.state[setname].permutation, iter->second.state[setname].size, omod), omod);
					if (table[q] == -1){
						table[q] = len + 1;
						c++;
					}
				}
			}      
		}
		len++;
		if (ignore.empty()) // Dont write if first pass
			std::cout << c << " positions at depth " << len << "\n"; 
	}while(c > 0);
	
	if (!ignore.empty()){ // If some pieces are to be ignored, use first pass to generate all
								// solved positions. Then generate the real table.
		c = 0;
		for (int i = 0; i < tablesize; i++){
			if (table[i] != -1){
				std::vector<int> tmp_o = oIndex2Vector(i, vector_size, omod);
				bool solved_pos = true;
				for (int j = 0; j < vector_size; j++)
					if (ignore[j] == 0 && tmp_o[j] != solved[j])
						solved_pos = false;
				if (solved_pos){
					table[i] = 0;
					c++;
				}
				else
					table[i] = -1;
			}
		}
		std::cout << c << " solved positions.\n";
		
		int len = 0;
		int c;
		do
		{
			c = 0;
			for (int p = 0; p < tablesize; p++){
				if (table[p] == len){
					for (iter = moves.begin(); iter != moves.end(); iter++){
						int q = oVector2Index(applySubmoveO(oIndex2Vector(p, vector_size, omod), iter->second.state[setname].orientation, iter->second.state[setname].permutation, iter->second.state[setname].size, omod), omod);
						if (table[q] == -1){
							table[q] = len + 1;
							c++;
						}
					}
				}
			}      
			len++;
			std::cout << c << " positions at depth " << len << "\n"; 
		}while(c > 0);
	}
	
	return table;
}

// Complete table, unique pieces
static std::vector<char> buildCompletePermutationPruningTable(std::vector<int> solved, MoveList moves, int setname, std::vector<int> ignore)
{
	std::cout << "Building pruning for " << setnameFromIndex(setname) << " permutation.\n";
	std::vector<char> table;
	int vector_size = solved.size();
	MoveList::iterator iter;
	int tablesize = 1;
	tablesize = factorial(solved.size());
	
	table.resize(tablesize);
	for (int i = 0; i < tablesize; i++)
		table[i] = -1;
		
	std::cout << "tablesize " << tablesize << "\n";

	table[pVector2Index(solved)] = 0; // Put solved position in table

	int len = 0;
	int c;
	do
	{
		c = 0;
		for (int p = 0; p < tablesize; p++){
			if (table[p] == len){
				for (iter = moves.begin(); iter != moves.end(); iter++){
					int q = pVector2Index(applySubmoveP(pIndex2Array(p, vector_size), iter->second.state[setname].permutation, vector_size), vector_size);
					if (table[q] == -1){
						table[q] = len + 1;
						c++;
					}
				}
			}      
		}
		len++;
		if (ignore.empty())
			std::cout << c << " positions at depth " << len << "\n";
		else
			std::cout << c << " positions in phase one, depth " << len << "\n"; 
	}while(c > 0);

	if (!ignore.empty()){
		c = 0;
		for (int i = 0; i < tablesize; i++){
			if (table[i] != -1){
				int* tmp_p = pIndex2Array(i, vector_size);
				bool solved_pos = true;
				for (int j = 0; j < vector_size; j++)
					if (ignore[j] == 0 && tmp_p[j] != solved[j])
						solved_pos = false;
				if (solved_pos){
					table[i] = 0;
					c++;
				}
				else
					table[i] = -1;
				delete tmp_p;
			}
		}
		std::cout << c << " solved positions.\n";
		int len = 0;
		int c;
		do
		{
			c = 0;
			for (int p = 0; p < tablesize; p++){
				if (table[p] == len){
					for (iter = moves.begin(); iter != moves.end(); iter++){
						int q = pVector2Index(applySubmoveP(pIndex2Array(p, vector_size), iter->second.state[setname].permutation, vector_size), vector_size);
						if (table[q] == -1){
							table[q] = len + 1;
							c++;
						}
					}
				}      
			}
			len++;
			std::cout << c << " positions at depth " << len << "\n"; 
		}while(c > 0);
	}

	return table;
}

// Complete table, not unique pieces
static std::vector<char> buildCompletePermutationPruningTable3(std::vector<int> solved, MoveList moves, int setname, std::vector<int> ignore)
{
	std::cout << "Building pruning for " << setnameFromIndex(setname) << " permutation\n";
	std::vector<char> table;
	int vector_size = solved.size();
	MoveList::iterator iter;
	int tablesize = combinations(solved);
		
	table.resize(tablesize);
	for (int i = 0; i < tablesize; i++)
		table[i] = -1;
		
	std::cout << "tablesize " << tablesize << "\n";

	table[pVector3Index(solved)] = 0; // Put solved position in table

	int len = 0;
	int c;
	do
	{
		c = 0;
		for (int p = 0; p < tablesize; p++){
			if (table[p] == len){
				for (iter = moves.begin(); iter != moves.end(); iter++){
					// FIX, assumes that inverses to all moves are also one move
					int q = pVector3Index(applySubmoveP(pIndex3Array(p, solved), iter->second.state[setname].permutation, vector_size), vector_size);
					// FIX
					if (table[q] == -1){
						table[q] = len + 1;
						c++;
					}
				}
			}      
		}
		len++;
		if (ignore.empty())
			std::cout << c << " positions at depth " << len << "\n"; 
	}while(c > 0);
	
	if (!ignore.empty()){
		c = 0;
		for (int i = 0; i < tablesize; i++){
			if (table[i] != -1){
				int* tmp_p = pIndex3Array(i, solved);
				bool solved_pos = true;
				for (int j = 0; j < vector_size; j++)
					if (ignore[j] == 0 && tmp_p[j] != solved[j])
						solved_pos = false;
				if (solved_pos){
					table[i] = 0;
					c++;
				}
				else
					table[i] = -1;
				delete tmp_p;
			}
		}
		std::cout << c << " solved positions.\n";

		int len = 0;
		int c;
		do
		{
			c = 0;
			for (int p = 0; p < tablesize; p++){
				if (table[p] == len){
					for (iter = moves.begin(); iter != moves.end(); iter++){
						// FIX, assumes that inverses to all moves are also one move
						int q = pVector3Index(applySubmoveP(pIndex3Array(p, solved), iter->second.state[setname].permutation, vector_size), vector_size);
						// FIX
						if (table[q] == -1){
							table[q] = len + 1;
							c++;
						}
					}
				}      
			}
			len++;
			std::cout << c << " positions at depth " << len << "\n"; 
		}while(c > 0);

	}
	return table;
}

static __gnu_pbds::gp_hash_table<std::vector<long long>, char, vec_long_long_hash> buildPartialOrientationPruningTable(std::vector<int> solved, MoveList moves, int setname, int omod, std::vector<int> ignore)
{
	std::cout << "Building partial pruning table for " << setnameFromIndex(setname) << " orientation.\n";
	__gnu_pbds::gp_hash_table<std::vector<long long>, char, vec_long_long_hash> table;
	__gnu_pbds::gp_hash_table<std::vector<long long>, char, vec_long_long_hash> old_table;
	__gnu_pbds::gp_hash_table<std::vector<long long>, char, vec_long_long_hash>::iterator iter2;
	MoveList::iterator iter;

	table[packVector(solved)] = 0; // Put solved position in table

	int len = 0;
	int c, tot_c;
	tot_c = 0;
	bool abort = false;

	do
	{
		c = 0;
		for (iter2 = table.begin(); iter2 != table.end(); iter2++){
			if (iter2->second == len && !abort){
				std::vector<int> pos = unpackVector(iter2->first);
				for (iter = moves.begin(); iter != moves.end(); iter++){
					std::vector<int> q = applySubmoveO(pos, iter->second.state[setname].orientation, iter->second.state[setname].permutation, iter->second.state[setname].size, omod);
					std::vector<long long> newpos = packVector(q);
					if (table.find(newpos) == table.end()){
						table[newpos] = len + 1;
						c++;
						tot_c++;
						if (tot_c >= MAX_PARTIAL_ORIENTATION_TABLE_SIZE){
							abort = true;
							break;
						}
					}
				}
			}
		}
		if (!abort)
			old_table = table;
		len++;
		std::cout << c << " positions at depth " << len << "\n"; 
			
	}while(c > 0 && !abort);
	if (abort){
		std::cout << "Too many positions at depth " << len << ", removing.\n";
		return old_table;
	}
	
	return table;
}


static __gnu_pbds::gp_hash_table<std::vector<long long>, char, vec_long_long_hash> buildPartialPermutationPruningTable(std::vector<int> solved, MoveList moves, int setname, std::vector<int> ignore)
{
	std::cout << "Building partial pruning for " << setnameFromIndex(setname) << " permutation.\n";
	__gnu_pbds::gp_hash_table<std::vector<long long>, char, vec_long_long_hash> table;
	__gnu_pbds::gp_hash_table<std::vector<long long>, char, vec_long_long_hash> old_table;

	__gnu_pbds::gp_hash_table<std::vector<long long>, char, vec_long_long_hash>::iterator iter2;
	MoveList::iterator iter;

	std::vector<long long> first_key = packVector(solved);
	table[first_key] = 0; // Put solved position in table

	if (!ignore.empty()){
		std::vector<int> repermutation;
		std::vector<int> first_perm;
		for (unsigned int i = 0; i < ignore.size(); i++)
			if (ignore[i] == 1)
				repermutation.push_back(i);
		if (repermutation.size() > 8){
			std::cout << "Can't ignore permutation of more than 8 pieces in a big set.\n";
			std::cout << "Set: " << setname << "\n";
			exit(-1);
		}
		while(next_permutation(repermutation.begin(), repermutation.end())){
			std::vector<int> tmp_perm;
			tmp_perm = solved;
			int v = 0;
			
			for (unsigned int i = 0; i < solved.size(); i++){
				if (ignore[i] == 1){
					tmp_perm[i] = solved[repermutation[v]];
					v++;
				}
			}
			table[packVector(tmp_perm)] = 0;
		}
		std::cout << table.size() << " solved positions.\n";
	}

	int len = 0;
	int c, tot_c;
	tot_c = 0;
	bool abort = false;
	do
	{
		c = 0;
		for (iter2 = table.begin(); iter2 != table.end(); iter2++){
			if (iter2->second == len && !abort){
				std::vector<int> pos = unpackVector(iter2->first);
				for (iter = moves.begin(); iter != moves.end(); iter++){
					std::vector<int> q = applySubmoveP(pos , iter->second.state[setname].permutation, iter->second.state[setname].size);
					std::vector<long long> newpos = packVector(q);
					if (table.find(newpos) == table.end()){
						table[newpos] = len + 1;
						c++;
						tot_c++;
						if (tot_c >= MAX_PARTIAL_PERMUTATION_TABLE_SIZE){
							abort = true;
							break;
						}
					}
				}
			}      
		}
		if (!abort)
			old_table = table;
		len++;
		std::cout << c << " positions at depth " << len << "\n";
	}while(c > 0 && !abort);
	
	if (abort){
		std::cout << "Too many positions at depth " << len << ", removing.\n";
		return old_table;
	}

	return table;
}

static int maxDepth(__gnu_pbds::gp_hash_table<std::vector<long long>, char, vec_long_long_hash> table){
	int maxdepth = 0;
	__gnu_pbds::gp_hash_table<std::vector<long long>, char, vec_long_long_hash>::iterator iter;
	for (iter = table.begin(); iter != table.end(); iter++)
		if (maxdepth < iter->second)
			maxdepth = iter->second;                     
	return maxdepth;        
}

// Function checks the tables and assign flags accordingly
static void updateDatasets(PieceTypes& datasets, PruneTable& tables)
{
	PruneTable::iterator iter;
	for (iter = tables.begin(); iter != tables.end(); iter++){
		if (iter->second.permutation.size() >= 1)
			datasets[iter->first].ptabletype = TABLE_TYPE_COMPLETE;
		else if (iter->second.partialpermutation.size() >= 1)
			datasets[iter->first].ptabletype = TABLE_TYPE_PARTIAL;
		else
			datasets[iter->first].ptabletype = TABLE_TYPE_NONE;

		double tablesize = 1.0;
		for (int i = 0; i < datasets[iter->first].size; i++)
			tablesize *= datasets[iter->first].omod;  // tablesize := omod ^ solved.size() 
									// checking for numbers getting to large might be smart
		if (iter->second.orientation.size() < 1)
			datasets[iter->first].otabletype = TABLE_TYPE_NONE;
		else if (tablesize <= MAX_COMPLETE_ORIENTATION_TABLE_SIZE)
			datasets[iter->first].otabletype = TABLE_TYPE_COMPLETE;
		else
			datasets[iter->first].otabletype = TABLE_TYPE_PARTIAL;
	}
}

static bool prune(Position& state, int depth, PieceTypes& datasets, PruneTable& prunetables){
	for (int iter2=0; iter2<state.size(); iter2++) {

		// Orientation pruning
		if (datasets[iter2].otabletype == TABLE_TYPE_COMPLETE){
			int index = oVector2Index(state[iter2].orientation, state[iter2].size, datasets[iter2].omod);
			if (prunetables[iter2].orientation[index]  > depth){
				return true;
			}
		}
		else if (datasets[iter2].otabletype == TABLE_TYPE_PARTIAL){
			std::vector<long long> index = packVector(state[iter2].orientation, state[iter2].size);
			
			if (prunetables[iter2].partialorientation_depth >= depth){
				if (prunetables[iter2].partialorientation.find(index) != prunetables[iter2].partialorientation.end()){ // If the position exist in the table then...
					if (prunetables[iter2].partialorientation[index] > depth){
						return true;
					}                         
				}
				else{
					return true;
				}
			}
		}
		// Permutation pruning
		if (datasets[iter2].ptabletype == TABLE_TYPE_COMPLETE && datasets[iter2].uniqueperm){
			int index = pVector2Index(state[iter2].permutation, state[iter2].size);
			if (prunetables[iter2].permutation[index]  > depth){
				return true;
			}
		}
		else if (datasets[iter2].ptabletype == TABLE_TYPE_COMPLETE && !datasets[iter2].uniqueperm){
			long long index = pVector3Index(state[iter2].permutation, state[iter2].size);
			if (prunetables[iter2].permutation[index]  > depth){
				return true;
			}
		}
		else if (datasets[iter2].ptabletype == TABLE_TYPE_PARTIAL){;
			std::vector<long long> index = packVector(state[iter2].permutation, state[iter2].size);

			if (prunetables[iter2].partialpermutation_depth >= depth){
				if (prunetables[iter2].partialpermutation.find(index) != prunetables[iter2].partialpermutation.end()){
					if (prunetables[iter2].partialpermutation[index] > depth){
						return true;
					}
				}
				else{
					return true;
				}
			}
		}
	}
	return false;
}

#endif
